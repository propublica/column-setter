// ------------------------------------------------------------
// COLUMN SETTER v2.0
// 
// Updates:
// - Now supports a mix of 
// ------------------------------------------------------------

// ------------------------------------------------------------
// FUNCTIONS
// ------------------------------------------------------------
// invalid()
// wrong-type()
// missing()
// optional()
// ----------------------------------------
// Column Setter uses invalid(), wrong-type(), missing(), and
// optional() to build error messages.

@function invalid($call, $arg2:null, $arg3:null, $arg4:null) {
	@if $arg2 and $arg3 and $arg4 {
		@return "'#{$call}(#{$arg2},#{$arg3},#{$arg4})' is invalid because ";
	}
	@if $arg2 and $arg3 and not $arg4 {
		@return "'#{$call}(#{$arg2},#{$arg3})' is invalid because ";
	}
	@if $arg2 and not $arg3 and not $arg4 {
		@return "'#{$call}(#{$arg2})' is invalid because ";
	}
	@if not $arg2 {
		@return "'#{$call}()' is invalid because ";
	}
}
@function wrong-type($type, $arg2:null, $arg3:null) {
	@if $arg2 and $arg3 {
		@return "'#{$arg2}' and '#{$arg3}' are not #{$type}s";
	}
	@if not $arg3 {
		@return "'#{$arg2}' is not a #{$type}";
	}
}
@function missing($number) {
	@if $number < 2 {
		@return "an argument is missing. ";
	}
	@if $number >= 2 {
		@return "arguments are missing. ";
	}
}
@function optional($number,$current,$correct) {
	@return "the optional #{$number} argument (currently '#{$current}') will only accept a value of '#{$correct}'. ";
}

// ----------------------------------------
// bp-attribute()
// ----------------------------------------
// Column Setter uses the bp-attribute() to retrieve the values
// of breakpoint attributes (such as "cols" and "min"), found
// in the $breakpoints map in _column-settings.scss.
//
// EXAMPLE: To access the minimum measurement of the "sm"
// breakpoint...
//
// bp-attribute(sm, min-width)
//
// ...returns something like this:
//
// 40em

@function bp-attribute($bp-name, $bp-attribute) {
	@return map-get(map-get($breakpoints, $bp-name), $bp-attribute);
}

// ----------------------------------------
// bp-validator() (UNFINISHED)
// ----------------------------------------
// Column Setter uses the bp-validator() to ensure that there
// are no errors in the $breakpoints map in
// _column-settings.scss.

@function bp-validator() {
	@if type-of($mar) != number or unitless($mar) == false {
		@warn "Here is the bp-validator $mar warning.";
	}
	@if type-of($col) != number or unitless($col) == false {
		@warn "Here is the bp-validator $col warning.";
	}
	@if type-of($gut) != number or unitless($gut) == false {
		@warn "Here is the bp-validator $gut warning.";
	}
	@if type-of($pad) != number or unitless($pad) == false {
		@warn "Here is the bp-validator $pad warning.";
	}
	@for $i from 1 through length($breakpoints) {
		@if type-of(map-get(map-get($breakpoints, (nth(map-keys($breakpoints), $i))), cols)) != number or unitless(map-get(map-get($breakpoints, (nth(map-keys($breakpoints), $i))), cols)) == false {
			@warn "Here is the bp-validator cols warning.";
		}
	}
}

// ----------------------------------------
// fluidWidth()
// ----------------------------------------
// Column Setter uses fluidWidth() to calculate the width of a
// span of columns, derived from the proportional width
// variables whose customizable values are defined at the top
// of _column-settings.scss. fluidWidth() will only work with
// unitless values.
//
// EXAMPLE: For a width spanning 6 columns...
//
// fluidWidth(6)
//
// ...returns something like this:
//
// 538

@function fluidWidth($width) {
	@return (($col * $width) + ($gut * ($width - 1)));
}

// ----------------------------------------
// colspan()
// ----------------------------------------
// colspan() allows the user to generate grid-based width
// values, derived from the variables whose customizable values
// are defined at the top of _column-settings.scss.
//
// EXAMPLE: For a width spanning 6 of 12 columns...
//
// width: colspan(6,12);
//
// ...might compile to something like this...
//
// width: 48.82033%;
//
// ...or something like this:
//
// width: calc((((100% - 3em) / 4) * 3) + 2em);

$colspan-lesson: "A 'colspan' function call must include the unitless numeric column widths of both the target and its container, e.g. 'colspan(4,8)'. The target width can also be specified as 'p' (for $pad width) or 'g' (for $gut width).";

@function colspan($target:null, $container:null, $addgut:false, $neg:false) {
	@if $target and $container { // If a target and container have been specified
		@if $target == $container { // If the target and container are the same
			@return 100%;
		} @else if type-of($container) == "number" and unitless($container) == true { // If the container is a unitless number

			$addgutAmount: 0;
			$negAmount: 1;
			$negOpen: "";
			$negClose: "";

			@if unitless($gut) == false { // If gutters are fixed width
				@if $addgut == true { // If a gutter is added to the desired width
					$addgutAmount: $gut;
				}
			} @else if $addgut == true { // If gutters are fluid width and a gutter is added to the desired width
				@if unitless($col) { // If columns are fluid width
					$addgutAmount: percentage($gut / fluidWidth($container));
				} @else { // If columns are fixed width
					$addgutAmount: 1;
				}
			}

			@if $neg == true { // If the desired width is negative
				$negAmount: -1;
				$negOpen: "(";
				$negClose: ") * " + $negAmount;
			}

			@if $target == 0 {
				@return 0;
			} @else if $target == "p" { // If the target is "p" (padding)
				@if $addgut == true { // If a gutter is added to the desired width
					@warn "$addgut can't be used with p or g.";
					@return false;
				} @else if $pad == 0 {
					@return 0;
				} @else if not unitless($pad) { // If padding is fixed width
					@return $pad * $negAmount;
				} @else if unitless($col) and unitless($gut) { // If padding, columns, and gutters are fluid width
					@return percentage($pad / fluidWidth($container)) * $negAmount;
				} @else if unitless($col) { // If padding and columns are fluid width and gutters are fixed width
					@return calc(#{$negOpen}((100% - #{$gut * ($container - 1)}) / #{$container}) * #{$pad / $col}#{$negClose});
				} @else if unitless($gut) { // If padding and gutters are fluid width and columns are fixed width
					@return calc(#{$negOpen}((100% - #{$col * $container}) / #{$container - 1}) * #{$pad / $gut}#{$negClose});
				} @else { // If padding is fluid width and columns and gutters are fixed width
					@warn "For padding to be fluid width, columns and/or gutters must also be fluid width.";
					@return false;
				}
			} @else if $target == "g" { // If the target is "g" (gutter)
				@if $addgut == true { // If a gutter is added to the desired width
					@warn "$addgut can't be used with p or g.";
					@return false;
				} @else if $gut == 0 {
					@return 0;
				} @else if not unitless($gut) { // If gutters are fixed width
					@return $gut * $negAmount;
				} @else if unitless($col) { // If gutters and columns are fluid width
					@return (percentage($gut / fluidWidth($container)) + $addgutAmount) * $negAmount;
				} @else { // If gutters are fluid width and columns are fixed width
					@return calc(#{$negOpen}(100% - #{$col * $container}) / #{$container - 1}#{$negClose});
				}
			} @else if type-of($target) == "number" and unitless($target) == true { // If the target is a unitless number
				@if not unitless($col) { // If columns are fixed width
					@if unitless($gut) { // If gutters are fluid width
						@return calc(#{$negOpen}(((100% - #{$col * $container}) / #{$container - 1}) * #{$target - 1 + $addgutAmount}) + #{$col * $target}#{$negClose});
					} @else if unit($col) == unit($gut) { // If columns and gutters are fixed width and use the same units
						@return (($col * $target) + ($gut * ($target - 1)) + $addgutAmount) * $negAmount;
					} @else { // If columns and gutters are fixed width and use different units
						@return calc(#{$negOpen}#{($col * $target)} + #{($gut * ($target - 1)) + $addgutAmount}#{$negClose});
					}
				} @else if unitless($gut) { // If columns are fluid width and gutters are fluid width
					@return (percentage(fluidWidth($target) / fluidWidth($container)) + $addgutAmount) * $negAmount;
				} @else { // If columns are fluid width and gutters are fixed width
					@return calc(#{$negOpen}(((100% - #{$gut * ($container - 1)}) / #{$container}) * #{$target}) + #{($gut * ($target - 1)) + $addgutAmount}#{$negClose});
				}
			} @else { // If the specified target is not "m", "p", "g", or a unitless number
				@warn "A colspan() target must be either 'p' (padding), 'g' (gutter), or a unitless number.";
				@return false;
			}
		} @else { // If the specified container is not a unitless number
			@warn "A colspan() container must be a unitless number.";
			@return false;
		}
	} @else if $target and not $container { // If a target is specified but not a container
		@warn "colspan() requires a container to be specified.";
		@return false;
	} @else if not $target { // If neither target nor container are specified
		@warn "colspan() requires a target and container to be specified.";
		@return false;
	}
}

// ------------------------------------------------------------
// MIXINS
// ------------------------------------------------------------
// full-width
// ----------------------------------------
// The "full-width" mixin allows the user to break an element
// out of the grid and into the margins, taking up the full
// width of the viewport.

@mixin full-width {
	width: auto;
	margin-left: calc(-50vw + 50%);
	margin-right: calc(-50vw + 50%);
}

// ----------------------------------------
// breakpoint
// breakpoint-max
// breakpoint-range
// ----------------------------------------
// The three flavors of the "breakpoint" mixin allow the user
// to generate width-based media queries using the breakpoint
// names and values defined in the $breakpoints map in
// _column-settings.scss.

$valid-bp-names: "Current valid breakpoint names: " + map-keys($breakpoints) + ".";
$bp-min-lesson: "A 'breakpoint-min' mixin call must contain a valid breakpoint name, e.g. 'breakpoint-min(small)'. " + $valid-bp-names;
$bp-max-lesson: "A 'breakpoint-max' mixin call must contain a valid breakpoint name, e.g. 'breakpoint-max(large)'. " + $valid-bp-names;
$bp-range-lesson: "A 'breakpoint-range' mixin call must contain valid minimum and maximum breakpoint names, e.g. 'breakpoint-range(small,large)'. " + $valid-bp-names;

// @include breakpoint-min(lg) { ... }
//
// ...compiles to something like this:
//
// @media screen and (min-width: 50em) { ... }

@mixin breakpoint-min($bp:null) {
	$all-is-well: true;
	@if $bp {
		@if not map-has-key($breakpoints, $bp) {
			$all-is-well: false;
			@warn invalid("breakpoint-min",$bp) + wrong-type("valid breakpoint name",$bp) + ". " + $bp-min-lesson;
		}
	} @else {
		$all-is-well: false;
		@warn invalid("breakpoint-min") + missing(1) + $bp-min-lesson;
	}
	@if $all-is-well == true {
		@media screen and (min-width: bp-attribute($bp, min-width)) { @content; }
	}
}

// @include breakpoint-max(lg) { ... }
//
// ...compiles to something like this:
//
// @media screen and (max-width: 50em) { ... }

@mixin breakpoint-max($bp:null) {
	$all-is-well: true;
	@if $bp {
		@if not map-has-key($breakpoints, $bp) {
			$all-is-well: false;
			@warn invalid("breakpoint-max",$bp) + wrong-type("valid breakpoint name",$bp) + ". " + $bp-min-lesson;
		}
	} @else {
		$all-is-well: false;
		@warn invalid("breakpoint-max") + missing(1) + $bp-min-lesson;
	}
	@if $all-is-well == true {
		@media screen and (max-width: bp-attribute($bp, min-width)) { @content; }
	}
}

// @include breakpoint-range(md, lg) { ... }
//
// ...compiles to something like this:
//
// @media screen and (min-width: 40em) and (max-width: 50em) { ... }

@mixin breakpoint-range($bp-min:null, $bp-max:null) {
	$all-is-well: true;
	@if $bp-min and $bp-max {
		@if not map-has-key($breakpoints, $bp-min) and not map-has-key($breakpoints, $bp-max) {
			$all-is-well: false;
			@warn invalid("breakpoint-range",$bp-min,$bp-max) + wrong-type("valid breakpoint name",$bp-min,$bp-max) + ". " + $bp-range-lesson;
		}
		@if not map-has-key($breakpoints, $bp-min) and map-has-key($breakpoints, $bp-max) {
			$all-is-well: false;
			@warn invalid("breakpoint-range",$bp-min,$bp-max) + wrong-type("valid breakpoint name",$bp-min) + ". " + $bp-range-lesson;
		}
		@if map-has-key($breakpoints, $bp-min) and not map-has-key($breakpoints, $bp-max) {
			$all-is-well: false;
			@warn invalid("breakpoint-range",$bp-min,$bp-max) + wrong-type("valid breakpoint name",$bp-max) + ". " + $bp-range-lesson;
		}
	}
	@if $bp-min and not $bp-max {
		$all-is-well: false;
		@if map-has-key($breakpoints, $bp-min) {
			@warn invalid("breakpoint-range",$bp-min) + missing(1) + $bp-range-lesson;
		} @else {
			@warn invalid("breakpoint-range",$bp-min) + wrong-type("valid breakpoint name",$bp-min) + ", and " + missing(1) + $bp-range-lesson;
		}
	}
	@if not $bp-min {
		$all-is-well: false;
		@warn invalid("breakpoint-range") + missing(2) + $bp-range-lesson;
	}
	@if $all-is-well == true {
		@media screen and (min-width: bp-attribute($bp-min, min-width)) and (max-width: bp-attribute($bp-max, min-width)) { @content }
	}
}

// ----------------------------------------
// grid
// ----------------------------------------
// The "grid" mixin allows the user to identify the class of
// the primary containing element in which their grid-aligned
// content lives. The mixin uses all of the info from the
// width and breakpoint variables defined at the top of
// _column-settings.scss to specify appropriate margin widths
// for the grid container at each breakpoint. Optionally
// including "overlay" as a second argument will add a
// translucent grid overlay on top of the grid container which
// can be used in production to ensure that your design is
// aligning to the grid as intended.
//
// EXAMPLE: If _column-settings.scss defines two breakpoints
// and the primary grid container has a class of "content"...
//
// @include grid(content);
//
// ...compiles to something like this:
//
// @media screen and (min-width: 0) {
//   .content {
//     margin: 0 3.38638%;
//   }
// }
// @media screen and (min-width: 30em) {
//   .content {
//     margin: 0 4.36194%;
//   }
// }

$grid-lesson: "A 'grid' mixin call must include a valid class name, e.g. 'grid(content);'. It may optionally include a second argument of 'overlay' (e.g. 'grid(content,overlay);') to create a translucent grid overlay on top of the grid container.";

@mixin grid($class:null, $overlay:null) {
	$all-is-well: true;
	@if not $class {
		$all-is-well: false;
		@warn invalid("grid") + missing(1) + $grid-lesson;
	}
	@if $overlay != "overlay" and $overlay != null {
		$all-is-well: false;
		@warn invalid("grid",$class,$overlay) + optional("second",$overlay,"overlay") + $grid-lesson;
	}
	@if $all-is-well == true {
		.#{$class} {
			$horiz-margin: 0;
			@each $bp, $value in $breakpoints { // For each breakpoint
				@include breakpoint-min($bp) { // Create a media query
					@if map-has-key(map-get($breakpoints, $bp), margin) { // If this breakpoint has custom margins
						@if bp-attribute($bp, margin) == 0 {
							$horiz-margin: 0;
						} @else if unitless(bp-attribute($bp, margin)) { // If margins are fluid width
							@if unitless($col) and unitless($gut) { // If columns and gutters are fluid width
								$horiz-margin: colspan(bp-attribute($bp, margin), fluidWidth(bp-attribute($bp, cols)) + (bp-attribute($bp, margin) * 2));
							} @else if unitless($col) { // If columns are fluid width and gutters are fixed width
								$horiz-margin: calc((100% - #{(bp-attribute($bp, cols) - 1) * $gut}) * #{bp-attribute($bp, margin) / (($col * bp-attribute($bp, cols)) + (bp-attribute($bp, margin) * 2))});
							} @else if unitless($gut) { // If gutters are fluid width and gutters are fixed width
								$horiz-margin: calc((100% - #{bp-attribute($bp, cols) * $col}) * #{bp-attribute($bp, margin) / (($gut * (bp-attribute($bp, cols) - 1)) + (bp-attribute($bp, margin) * 2))});
							}
						} @else { // If margin is fixed width
							$horiz-margin: bp-attribute($bp, margin);
						}
					} @else { // If this breakpoint has no custom margins
						@if $mar == 0 {
							$horiz-margin: 0;
						} @else if unitless($mar) { // If margins are fluid width
							@if unitless($col) and unitless($gut) { // If columns and gutters are fluid width
								$horiz-margin: colspan($mar, fluidWidth(bp-attribute($bp, cols)) + ($mar * 2));
							} @else if unitless($col) { // If columns are fluid width and gutters are fixed width
								$horiz-margin: calc((100% - #{(bp-attribute($bp, cols) - 1) * $gut}) * #{$mar / (($col * bp-attribute($bp, cols)) + ($mar * 2))});
							} @else if unitless($gut) { // If gutters are fluid width and gutters are fixed width
								$horiz-margin: calc((100% - #{bp-attribute($bp, cols) * $col}) * #{$mar / (($gut * (bp-attribute($bp, cols) - 1)) + ($mar * 2))});
							}
						} @else { // If margins are fixed width
							$horiz-margin: $mar;
						}
					}
					margin: 0 $horiz-margin;
				}
			}

			@if $max-width { // If there is a max-width
				max-width: $max-width;
				$min-width: $max-width;
				$bp-final: nth(map-keys($breakpoints), -1); // The widest breakpoint
				@if map-has-key(map-get($breakpoints, $bp-final), margin) { // If the widest breakpoint has custom margins
					@if bp-attribute($bp, margin) == 0 {
						$min-width: $max-width;
					} @else if unitless(bp-attribute($bp-final, margin)) { // If margins are fluid width
						@if unitless($col) and unitless($gut) { // If columns and gutters are fluid width
							$min-width: ((((bp-attribute($bp-final, margin) / fluidWidth(bp-attribute($bp-final, cols))) * $max-width) * 2) + $max-width);
						} @else if unitless($col) { // If columns are fluid width and gutters are fixed width
							$min-width: calc(((#{$max-width} - #{(bp-attribute($bp-final, cols) - 1) * $gut}) * #{(bp-attribute($bp-final, margin) * 2) / ((bp-attribute($bp-final, cols) * $col) + (bp-attribute($bp-final, margin) * 2))}) + #{$max-width});
						} @else if unitless($gut) { // If gutters are fluid width and columns are fixed width
							$min-width: calc(((#{$max-width} - #{bp-attribute($bp-final, cols) * $col}) * #{(bp-attribute($bp-final, margin) * 2) / ((bp-attribute($bp-final, cols) * ($gut - 1)) + (bp-attribute($bp-final, margin) * 2))}) + #{$max-width});
						}
					} @else {
						$min-width: calc(#{$max-width} + (#{bp-attribute($bp-final, margin)} * 2));
					}
				} @else { // If the widest breakpoint has no custom margins
					@if $mar == 0 {
						$min-width: $max-width;
					} @else if unitless($mar) { // If margins are fluid width
						@if unitless($col) and unitless($gut) { // If columns and gutters are fluid width
							$min-width: (((($mar / (fluidWidth(bp-attribute($bp-final, cols)) + ($mar * 2))) * $max-width) * 2) + $max-width);
						} @else if unitless($col) { // If columns are fluid width and gutters are fixed width
							$min-width: calc(((#{$max-width} - #{(bp-attribute($bp-final, cols) - 1) * $gut}) * #{($mar * 2) / ((bp-attribute($bp-final, cols) * $col) + ($mar * 2))}) + #{$max-width});
						} @else if unitless($gut) { // If gutters are fluid width and columns are fixed width
							$min-width: calc(((#{$max-width} - #{bp-attribute($bp-final, cols) * $col}) * #{($mar * 2) / ((bp-attribute($bp-final, cols) * ($gut - 1)) + ($mar * 2))}) + #{$max-width});
						}
					} @else {
						$min-width: calc(#{$max-width} + (#{$mar} * 2));
					}
				}
				@media screen and (min-width: $min-width) {
					margin: 0 auto;
				}
			}
			@if $overlay == overlay {
				position: relative;
				$gc: rgba($grid-color, 0.1);
				$gp: rgba($grid-color, 0.2);
				$gg: rgba($grid-color, 0);
				&:before {
					content: "";
					display: block;
					position: absolute;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					z-index: 100;
					pointer-events: none;
					@each $bp, $value in $breakpoints {
						@include breakpoint-min($bp) {
							background-image: repeating-linear-gradient(
								to right,
								$gc,
								$gc colspan(1, bp-attribute($bp, cols)),
								$gg colspan(1, bp-attribute($bp, cols)),
								$gg colspan(1, bp-attribute($bp, cols), $addgut:true)
							);
						}
					}
				}
			}
		}
	}
}
